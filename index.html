<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>艦隊司令：戰略佈署</title>
    <style>
        :root {
            --bg: #0d1117; --card: #161b22; --accent: #58a6ff;
            --ship: #8b949e; --hit: #f85149; --miss: #30363d; --text: #c9d1d9;
        }
        body { background: var(--bg); color: var(--text); font-family: sans-serif; display: flex; flex-direction: column; align-items: center; padding: 20px; user-select: none; }
        .setup-container { display: flex; gap: 30px; margin-bottom: 20px; background: var(--card); padding: 20px; border-radius: 10px; border: 1px solid #30363d; }
        .ship-dock { display: flex; flex-direction: column; gap: 10px; width: 200px; }
        .draggable-ship { 
            background: var(--ship); border: 2px solid var(--accent); cursor: grab; 
            display: flex; border-radius: 4px; align-items: center; justify-content: center; font-size: 12px; color: #000;
        }
        .grid { display: grid; grid-template-columns: repeat(10, 35px); gap: 2px; background: #30363d; padding: 5px; border: 2px solid #444; }
        .cell { width: 35px; height: 35px; background: var(--cell); display: flex; align-items: center; justify-content: center; }
        .cell.over { background: rgba(88, 166, 255, 0.3); }
        .ship-on-board { background: var(--ship) !important; border: 1px solid var(--accent); }
        .hit { background: var(--hit) !important; color: white; }
        .miss { background: var(--miss) !important; }
        
        .controls { margin: 20px; display: flex; gap: 10px; }
        button { background: #21262d; border: 1px solid #f0f6fc1a; color: var(--accent); padding: 8px 15px; border-radius: 6px; cursor: pointer; }
        button:hover { background: #30363d; }
        button.primary { background: var(--accent); color: white; }
        
        #status-msg { height: 30px; font-weight: bold; color: var(--accent); }
        .hidden-ship .ship-on-board { background: var(--cell) !important; border: none; }
    </style>
</head>
<body>

    <h1>艦隊司令：戰略佈署</h1>
    <div id="status-msg">階段：請將船隻拖拽至棋盤，點擊船隻可旋轉</div>

    <div class="setup-container">
        <div class="grid-wrapper">
            <h3>玩家基地 (佈署區)</h3>
            <div id="p1-board" class="grid"></div>
        </div>
        
        <div class="ship-dock" id="dock">
            <h3>船塢 (拖曳放置)</h3>
            <div class="draggable-ship" draggable="true" data-len="5" id="s1">航空母艦 (5)</div>
            <div class="draggable-ship" draggable="true" data-len="4" id="s2">戰艦 (4)</div>
            <div class="draggable-ship" draggable="true" data-len="3" id="s3">巡洋艦 (3)</div>
            <div class="draggable-ship" draggable="true" data-len="3" id="s4">潛艇 (3)</div>
            <div class="draggable-ship" draggable="true" data-len="2" id="s5">驅逐艦 (2)</div>
        </div>

        <div class="grid-wrapper">
            <h3>敵方海域 (攻擊區)</h3>
            <div id="p2-board" class="grid hidden-ship"></div>
        </div>
    </div>

    <div class="controls">
        <button onclick="clearBoard()">清除盤面 [C]</button>
        <button onclick="undoLast()">回上一步 [Z]</button>
        <button class="primary" id="start-btn" onclick="startGame()">開始遊戲 [Enter]</button>
    </div>

    <script>
        const SIZE = 10;
        let p1Data = Array(SIZE).fill().map(() => Array(SIZE).fill(0));
        let p2Data = Array(SIZE).fill().map(() => Array(SIZE).fill(0));
        let placedShips = []; // 紀錄放置順序以便回退
        let currentDragShip = null;
        let isVertical = false;
        let gameActive = false;

        // 初始化棋盤
        function render() {
            draw('p1-board', p1Data, true);
            draw('p2-board', p2Data, false);
        }

        function draw(id, data, isP1) {
            const el = document.getElementById(id);
            el.innerHTML = '';
            for(let r=0; r<SIZE; r++) {
                for(let c=0; c<SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell' + (data[r][c] === 1 ? ' ship-on-board' : '') + (data[r][c] === 2 ? ' hit' : '') + (data[r][c] === 3 ? ' miss' : '');
                    if(data[r][c] === 2) cell.innerText = '✕';
                    if(data[r][c] === 3) cell.innerText = '○';
                    
                    if(isP1 && !gameActive) {
                        cell.ondragover = e => { e.preventDefault(); cell.classList.add('over'); };
                        cell.ondragleave = () => cell.classList.remove('over');
                        cell.ondrop = e => handleDrop(e, r, c);
                    } else if(!isP1 && gameActive) {
                        cell.onclick = () => playerAttack(r, c);
                    }
                    el.appendChild(cell);
                }
            }
        }

        // 拖曳與旋轉邏輯
        document.querySelectorAll('.draggable-ship').forEach(ship => {
            ship.ondragstart = () => { currentDragShip = { len: parseInt(ship.dataset.len), id: ship.id }; };
            ship.onclick = () => { 
                isVertical = !isVertical; 
                ship.style.writingMode = isVertical ? 'vertical-rl' : 'horizontal-tb';
                document.getElementById('status-msg').innerText = `方向已切換：${isVertical ? '垂直' : '水平'}`;
            };
        });

        function handleDrop(e, r, c) {
            e.preventDefault();
            const {len, id} = currentDragShip;
            if (canPlace(p1Data, r, c, len, isVertical)) {
                const coords = [];
                for(let i=0; i<len; i++) {
                    let nr = isVertical ? r+i : r, nc = isVertical ? c : c+i;
                    p1Data[nr][nc] = 1;
                    coords.push({r: nr, c: nc});
                }
                placedShips.push({id, coords});
                document.getElementById(id).style.display = 'none';
                render();
            }
        }

        function canPlace(data, r, c, len, vert) {
            if ((vert && r + len > SIZE) || (!vert && c + len > SIZE)) return false;
            for(let i=0; i<len; i++) if(data[vert ? r+i : r][vert ? c : c+i] !== 0) return false;
            return true;
        }

        // 快捷功能
        function clearBoard() { location.reload(); }
        function undoLast() {
            if (placedShips.length === 0) return;
            const last = placedShips.pop();
            last.coords.forEach(p => p1Data[p.r][p.c] = 0);
            document.getElementById(last.id).style.display = 'flex';
            render();
        }

        function startGame() {
            if (placedShips.length < 5) return alert("請先放完所有船隻！");
            gameActive = true;
            document.getElementById('dock').style.display = 'none';
            document.getElementById('status-msg').innerText = "戰鬥開始！請點擊右側攻擊。";
            placeAIShips();
            render();
        }

        function placeAIShips() {
            [5,4,3,3,2].forEach(len => {
                let p = false;
                while(!p) {
                    let v = Math.random()<0.5, r=Math.floor(Math.random()*SIZE), c=Math.floor(Math.random()*SIZE);
                    if(canPlace(p2Data, r, c, len, v)) {
                        for(let i=0; i<len; i++) p2Data[v?r+i:r][v?c:c+i] = 1;
                        p = true;
                    }
                }
            });
        }

        // 攻擊與 AI 思考邏輯
        async function playerAttack(r, c) {
            if (p2Data[r][c] > 1) return;
            let hit = p2Data[r][c] === 1;
            p2Data[r][c] = hit ? 2 : 3;
            render();
            if (!hit) {
                document.getElementById('status-msg').innerText = "未命中，AI 正在思考中...";
                await new Promise(res => setTimeout(res, 1500)); // AI 思考感
                enemyTurn();
            } else {
                document.getElementById('status-msg').innerText = "命中！連擊開始！";
            }
        }

        async function enemyTurn() {
            let r, c;
            do { r = Math.floor(Math.random()*SIZE); c = Math.floor(Math.random()*SIZE); } while(p1Data[r][c] > 1);
            
            let hit = p1Data[r][c] === 1;
            p1Data[r][c] = hit ? 2 : 3;
            render();

            if (hit) {
                document.getElementById('status-msg').innerText = "AI 擊中了！它正在計劃下一步...";
                await new Promise(res => setTimeout(res, 2000)); // 增加連擊間隔
                enemyTurn();
            } else {
                document.getElementById('status-msg').innerText = "輪到你了！";
            }
        }

        // 快捷鍵
        window.onkeydown = e => {
            if(e.key.toLowerCase() === 'z') undoLast();
            if(e.key.toLowerCase() === 'c') clearBoard();
            if(e.key === 'Enter') startGame();
        };

        render();
    </script>
</body>
</html>
